âœ… Given Question:
You are given a string `morse` which is a mix of characters '.' and '-'.

It encodes a number using the following rules:
    - "." â†’ 0
    - "-." â†’ 1
    - "--" â†’ 2

Your task is to decode the string and print the resulting number.

âœ… Given Data:
You have:
    - A single string consisting of '.', '-' characters.
    - You need to parse it **left to right**, identifying:
        - Single dot ('.') â†’ 0
        - Dash-dot ('-.') â†’ 1
        - Dash-dash ('--') â†’ 2

âœ… Intuition:
The encoded number is a compressed form where:
    - Some symbols represent 1 character (like '.')
    - Others represent 2 characters (like '-.', '--')

So, we need to simulate a parser:
    - At each step, look at current character.
    - If itâ€™s '.', it's a 0.
    - If itâ€™s '-', check the **next** character to determine if itâ€™s '1' or '2'.
    - After consuming 2-character codes, skip the next character using `i++`.

------------------------------------------------------------
Approach-1: Simulation using Switch-Case
------------------------------------------------------------

    - Step 1: Initialize a `StringBuilder` to store the decoded output.
    - Step 2: Loop through the string one character at a time:
        - If char is '.', append "0".
        - If char is '-', look at next character:
            - If next is '.', it's "-." â†’ append "1"
            - If next is '-', it's "--" â†’ append "2"
            - Increment `i` to skip the second character in 2-char pattern.
    - Step 3: Return the final string.

âœ… ğŸ” Deep Dive:
    - âœ… Greedy Parsing:
        - Always match the smallest possible valid pattern left to right.
    - âœ… Why `i++` after '-' case?
        - Because we've already handled 2 characters, we move past both.

ğŸ•’ Time Complexity:
    - O(n)
        - Each character is processed once.
        - `i++` ensures no reprocessing of characters.
    
ğŸ§  Space Complexity:
    - O(n)
        - For the output `StringBuilder`, storing the decoded result.

